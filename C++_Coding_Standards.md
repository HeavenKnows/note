# C++ Coding Standards

## 

35. 不要继承“非基类”（独立类）
    * 如果一个类型不是作为基类来设计的，那么不要继承他，否则一定会出问题，编译器却很难发现这些问题（例如？？）；
    * 如果想要给这个“非基类”添加功能，那么添加非成员函数，而不是继承他；例如：
        + 想要给“值类”string添加功能，通常定义非成员函数要比继承string创建super_string要好；
        + 对于已经使用string的代码，可能需要改为新类型（为了一致性吧）；
        + 以string为参数的函数要想使用新类型的功能，就需要进行转换；
        + super_string的成员函数对string内部的访问权限并不比非成员函数大，因为string可能没有protected成员（因为他并没有设计成基类）；
        + 继承的复杂性导致容易出错，如super_string可能隐藏string的一些函数，处理string的代码会产生一些混淆；？？？
    * 为避免名字查找问题，需要将这些相关的非成员函数放在类的同一命名空间中；
    * 如果想要给这个“非基类”添加状态，那么使用组合（在一个新的类型中使用pImpl或者智能指针指向他）；同样以string为例：
        + 简单地在local_string中添加string的impl；
        + 可以防止被切片，部分析构的问题；
        + 想要访问string的成员函数，可以使用通道函数（local_string的成员函数简单地通过impl调用string的成员函数）；
        + 虽然编写通道函数很枯燥...但是比继承好得多，而且更安全；

36. 抽象艺术
    * 抽象接口是完全由（纯）虚函数构成的抽象类，**没有数据成员**，通常没有函数实现（注意纯虚函数是可以有实现的，effective C++）；
    * 依赖倒置原理DIP--Dependency Inversion Principle
        + 高层模块不应依赖底层模块，两者都应依赖抽象（我们的项目中？？？）；**这里的高/低层、上/下层，和我们项目中通常说的不是一个概念**
        + 抽象不应依赖于细节，相反，细节应依赖抽象；
    * DIP意味着层次结构应该以抽象类为根，而不是具体类；
    * 抽象基类定义功能，而不是实现功能--策略应该上推，而实现应该下放；
    * DIP的优点：
        + 健壮性：
            * 不稳定部分（实现）依赖稳定部分（抽象）；
            * 健壮的设计应将修改困在局部（不用修改上层抽象，只需要修改局部实现）；
            * 不健壮的设计会将小的修改传播到意料不到的部分去。具体基类的设计就是如此；（具体基类处于上层，有小的修改便会牵连甚广）
        + 灵活性：
            * 正确地建模抽象，有新的需求可以设计新的实现（不需要修改抽象模型）；
            * 而依赖具体细节的上层设计很难改变，新的需求会导致核心上层的修改；
        + 模块性：
            * 因为依赖层次简单，所以模块性好；
            * 相反，如果设计（上层）混合了实现细节，那么会出现复杂的依赖网，这样想把这个设计作为一个单元插入到另一个系统中实现重用，会变得困难；
    * 二次机会定律 law of second chance
        + 接口是最重要的需要保证正确的东西，因为其他东西以后都可以修改，但是接口错了，可能再也不允许修改了；
    * 抽象类中使用public virtual 析构函数（除非使用COM、CORBA这种对象代理--另一种内存管理机制）；
    * 例外：
        + 空基类优化（？？？）
        + 基于策略的设计（？？？）

37. 公有继承就是可替换性。继承不是为了重用，而是为了被重用
    * 公有继承是为了让已有的代码可以使用新的类的，而不是为了用已有代码实现新的类（这种情况应该用组合）。用基类指针指向派生类对象，通过该指针调用函数，可以无缝的调用派生类的函数版本而不用修改基类的代码。这才是可替换性，至于重用，我觉得这种说法不太合适。
    * 公用继承的目的是实现可替换性，公用继承的目的并不是为了派生类重用基类的代码，用基类代码实现自己。这种“用...来实现自己”应该用组合来建模。
    * 例外：通过继承策略类和混入类（提供了部分实现的虚基类）来添加功能是可以的，这并不是误用公有继承来建模“用...来实现”关系。
    * "继承的误用将破坏正确性。没有被正确实现的继承大多数会因为无法遵守**基类确定的显式或者隐式的约定而迷乱。这种约定可能是很微妙的**"，这些约定中很微妙的指哪些约定？（不知道哪些约定很容易被忽视）

38. 实施安全的覆盖（override）
    * 覆盖一个虚函数时，应该保持可替换性，要保持基类中函数的前后置条件（什么是前后置条件，比如？？）
    * 不要改变从虚函数继承来的默认参数，因为用基类指针多态访问时，默认参数使用的是静态绑定，实际使用的是基类的默认参数
    * 默认参数不是函数签名的一部分
    * 应该显式地将override函数重新声明为virtual（why？？为了清晰明确？？）
    * 谨防在虚拟类中隐藏重载函数？？？？在子类中实现一个基类没有的同名非虚函数将导致隐藏（看不到基类的同名非虚函数了）
    * 虽然派生类通常会有更多的数据成员，但是派生类所建模的是基类的子集（而不是超集），适用于基类的操作理应适用于派生类。
    * 什么是正确的覆盖呢：
        + 可以要求更少而提供更多
        + 不能要求更多而承诺更少（基类函数承诺了不会抛异常，派生类的覆盖也必须承诺不会抛异常）

39. 考虑将虚函数设置为非公有的，公有函数设置为非虚的
    * NVI模式
    * 明确公有函数的作用，虚拟函数的作用

40. 